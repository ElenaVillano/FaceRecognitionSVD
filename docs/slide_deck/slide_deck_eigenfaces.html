<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Eigen Faces</title>
    <meta charset="utf-8" />
    <meta name="author" content="Elena Villalobos Nolasco" />
    <meta name="author" content="Nancy Dira Mart铆nez Guzm谩n" />
    <meta name="author" content="Laura Marcela Tejada L贸pez" />
    <meta name="author" content="Santiago Battezati" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Eigen Faces
## aplicando los m茅todos de PCA, SVD y rotaciones de Jacobi
### Elena Villalobos Nolasco
### Nancy Dira Mart铆nez Guzm谩n
### Laura Marcela Tejada L贸pez
### Santiago Battezati
### ITAM

---

layout: true
background-position: 98% 5% 
background-size: 12%
&lt;div style="text-align: justify"&gt;  
---

<div>
<style type="text/css">.xaringan-extra-logo {
width: 110px;
height: 128px;
z-index: 0;
background-image: url(http://escolar.itam.mx/centro_tesis/img/logo-ITAM.png);
background-size: contain;
background-repeat: no-repeat;
position: absolute;
top:1em;right:1em;
}
</style>
<script>(function () {
  let tries = 0
  function addLogo () {
    if (typeof slideshow === 'undefined') {
      tries += 1
      if (tries < 10) {
        setTimeout(addLogo, 100)
      }
    } else {
      document.querySelectorAll('.remark-slide-content:not(.title-slide):not(.inverse):not(.hide_logo)')
        .forEach(function (slide) {
          const logo = document.createElement('div')
          logo.classList = 'xaringan-extra-logo'
          logo.href = null
          slide.appendChild(logo)
        })
    }
  }
  document.addEventListener('DOMContentLoaded', addLogo)
})()</script>
</div>

# ndice

###1. Introducci贸n

###2. PCA

###3. EigenFaces
  - Algoritmo con SVD
  - Algoritmo con Rotaciones de Jacobi
  
###4. Conclusiones

---

# Introducci贸n

Dos tendencias principales en los algoritmos para reconocer rostros:

- Algoritmos basados en la apariencia (hol铆sticos)
- Algoritmos basados en rasgos (features)

**Los algoritmos de clasificaci贸n m谩s utilizados para resolver el problema del reconocimiento de rostro han sido PCA y LDA.**

Eigenfaces y Fisherfaces son ejemplos de estos. Tambi茅n se han utilizado m茅todos bayesianos, entre otros.


&lt;img src="img_1.png" width="85%" style="display: block; margin: auto;" /&gt;

---

class: inverse, center, middle

# An谩lisis de Componentes Principales

---

# Planteamiento del Problema

El **An谩lisis de Componentes Principales** (PCA) se utiliza usualmente como una t茅cnica de visualizaci贸n, reducci贸n de dimensi贸n y tambi茅n como un paso intermedio en el an谩lisis de datos como t茅cnica explicatoria. Es por ello que **este m茅todo es uno de los usos principales de la SVD**.

Representa la selecci贸n de un nuevo conjunto de coordenadas, que obtenemos mediante rotaci贸n y traslaci贸n del sistema original a ejes, en donde se maximiza la varianza en cada direcci贸n.

&lt;img src="img_2.png" width="40%" style="display: block; margin: auto;" /&gt;

---

### El Problema de Optimizaci贸n

&lt;img src="img_3.png" width="130%" style="display: block; margin: auto;" /&gt;

---

# Implementaci贸n

**Pasos**

1. Estandarizaci贸n de variables
2. Selecci贸n del n煤mero de componentes principales seg煤n el porcentaje de varianza explicada
3. Utilizar el algoritmo de PCA, que podemos consultar en la documentaci贸n de sklearn
4. Interpretar las componentes principales




**Elecci贸n de las Componentes Principales**

- QCP que acumulen cierto porcentaje de la variaci贸n total.
- CP cuyos eigenvalores sean mayores que el promedio  炉 .
- Utilizar una gr谩fica de codo (scree plot).
- Verificar la significancia de las componentes m谩s grandes.

---

# Ventajas y Desventajas de PCA

**Ventajas**
- Reducci贸n de variables correlacionadas entre s铆.
- Mejora el desempe帽o del algoritmo.
- Reduce el sobreajuste.
- Puede proveer una mejor visualizaci贸n.


**Desventajas**
- Las componentes principales pueden ser sensibles a outliers.
- Las componentes principales son sensibles a distintos escalamientos de los datos originales.
- Dif铆cil interpretaci贸n de las componentes principales y de las visualizaciones.
- Puede haber una p茅rdida significativa de informaci贸n.

---
class: inverse, center, middle

# EigenFaces
Aplicando SVD

---

# Descripci贸n del Algoritmo

&lt;img src="img_4.png" width="120%" style="display: block; margin: auto;" /&gt;
---

# Implementaci贸n del Algoritmo

&lt;img src="img_5.png" width="60%" style="display: block; margin: auto;" /&gt;
---

# Implementaci贸n del Algoritmo
&lt;img src="img_6.png" width="60%" style="display: block; margin: auto;" /&gt;
---

# Implementaci贸n del Algoritmo

&lt;img src="img_7.png" width="50%" style="display: block; margin: auto;" /&gt;

---

# Implementaci贸n del Algoritmo

&lt;img src="img_8.png" width="80%" style="display: block; margin: auto;" /&gt;

&lt;img src="img_9.png" width="80%" style="display: block; margin: auto;" /&gt;

---

# Implementaci贸n del Algoritmo

&lt;img src="img_10.png" width="50%" style="display: block; margin: auto;" /&gt;

---

# Implementaci贸n del Algoritmo

&lt;img src="img_11.png" width="90%" style="display: block; margin: auto;" /&gt;
---

# Implementaci贸n del Algoritmo

&lt;img src="img_12.png" width="100%" style="display: block; margin: auto;" /&gt;
---

# Implementaci贸n del Algoritmo

&lt;img src="img_13.png" width="70%" style="display: block; margin: auto;" /&gt;
---
class: inverse, center, middle

# EigenFaces
Aplicando Rotaciones de Jacobi

---

# Descripci贸n del Algoritmo

El **m茅todo de rotaciones Jacobi one sided, es un m茅todo num茅rico para calcular SVD**. El m茅todo utiliza las rotaciones de Jacobi, una transformaci贸n de rotaci贸n, para construir a la matriz ortogonal V y llegar a W.

En este apartado, hacemos uso de este m茅todo, que construimos en una pr谩ctica anterior, como una forma de llegar a la descomposici贸n SVD e implementar el algoritmo Eigenfaces.


---

# Implementaci贸n del Algoritmo

&lt;img src="img_14.png" width="50%" style="display: block; margin: auto;" /&gt;

---

# Implementaci贸n del Algoritmo

&lt;img src="img_15.png" width="50%" style="display: block; margin: auto;" /&gt;

---

# Implementaci贸n del Algoritmo

&lt;img src="img_16.png" width="100%" style="display: block; margin: auto;" /&gt;

---
class: inverse, center, middle

# Conclusiones
Aplicaciones y enfoques alternativos

---

# Conclusiones y Aplicaciones

Uno de los principales desaf铆os en el reconocimiento de rostros viene dado por las **variaciones dadas en posici贸n (perspectiva), gestualidad e iluminaci贸n de las caras**.


Dos enfoques alternativos:

- Fisher Faces
- Tensor SVD


---

layout: false
class: inverse, center, middle

# Dudas
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
