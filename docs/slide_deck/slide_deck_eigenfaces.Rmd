---
title: "Eigen Faces"
subtitle: "aplicando los m茅todos de PCA, SVD y rotaciones de Jacobi"
author:
  - Elena Villalobos Nolasco
  - Nancy Dira Mart铆nez Guzm谩n
  - Laura Marcela Tejada L贸pez
  - Santiago Battezati
institute: "ITAM"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
layout: true
background-position: 98% 5% 
background-size: 12%
<div style="text-align: justify">  
---

```{r logo, echo=F}
#devtools::install_github("gadenbuie/xaringanExtra")
library(xaringanExtra)

xaringanExtra::use_logo(
  image_url = "http://escolar.itam.mx/centro_tesis/img/logo-ITAM.png",
  position = xaringanExtra::css_position(top = "1em", right = "1em")
)
```

# ndice

###1. Introducci贸n

###2. PCA

###3. EigenFaces
  - Algoritmo con SVD
  - Algoritmo con Rotaciones de Jacobi
  
###4. Conclusiones

---

# Introducci贸n

Dos tendencias principales en los algoritmos para reconocer rostros:

- Algoritmos basados en la apariencia (hol铆sticos)
- Algoritmos basados en rasgos (features)

**Los algoritmos de clasificaci贸n m谩s utilizados para resolver el problema del reconocimiento de rostro han sido PCA y LDA.**

Eigenfaces y Fisherfaces son ejemplos de estos. Tambi茅n se han utilizado m茅todos bayesianos, entre otros.


```{r, echo = F, eval=T, out.width="85%", fig.align='center'}
knitr::include_graphics("img_1.png")
```

---

class: inverse, center, middle

# An谩lisis de Componentes Principales

---

# Planteamiento del Problema

El **An谩lisis de Componentes Principales** (PCA) se utiliza usualmente como una t茅cnica de visualizaci贸n, reducci贸n de dimensi贸n y tambi茅n como un paso intermedio en el an谩lisis de datos como t茅cnica explicatoria. Es por ello que **este m茅todo es uno de los usos principales de la SVD**.

Representa la selecci贸n de un nuevo conjunto de coordenadas, que obtenemos mediante rotaci贸n y traslaci贸n del sistema original a ejes, en donde se maximiza la varianza en cada direcci贸n.

```{r, echo = F, eval=T, out.width="40%", fig.align='center'}
knitr::include_graphics("img_2.png")
```

---

### El Problema de Optimizaci贸n

```{r, echo = F, eval=T, out.width="130%", fig.align='center'}
knitr::include_graphics("img_3.png")
```

---

# Implementaci贸n

**Pasos**

1. Estandarizaci贸n de variables
2. Selecci贸n del n煤mero de componentes principales seg煤n el porcentaje de varianza explicada
3. Utilizar el algoritmo de PCA, que podemos consultar en la documentaci贸n de sklearn
4. Interpretar las componentes principales




**Elecci贸n de las Componentes Principales**

- QCP que acumulen cierto porcentaje de la variaci贸n total.
- CP cuyos eigenvalores sean mayores que el promedio  炉 .
- Utilizar una gr谩fica de codo (scree plot).
- Verificar la significancia de las componentes m谩s grandes.

---

# Ventajas y Desventajas de PCA

**Ventajas**
- Reducci贸n de variables correlacionadas entre s铆.
- Mejora el desempe帽o del algoritmo.
- Reduce el sobreajuste.
- Puede proveer una mejor visualizaci贸n.


**Desventajas**
- Las componentes principales pueden ser sensibles a outliers.
- Las componentes principales son sensibles a distintos escalamientos de los datos originales.
- Dif铆cil interpretaci贸n de las componentes principales y de las visualizaciones.
- Puede haber una p茅rdida significativa de informaci贸n.

---
class: inverse, center, middle

# EigenFaces
Aplicando SVD

---

# Descripci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="120%", fig.align='center'}
knitr::include_graphics("img_4.png")
```
---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="60%", fig.align='center'}
knitr::include_graphics("img_5.png")
```
---

# Implementaci贸n del Algoritmo
```{r, echo = F, eval=T, out.width="60%", fig.align='center'}
knitr::include_graphics("img_6.png")
```
---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="50%", fig.align='center'}
knitr::include_graphics("img_7.png")
```

---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="80%", fig.align='center'}
knitr::include_graphics("img_8.png")
```

```{r, echo = F, eval=T, out.width="80%", fig.align='center'}
knitr::include_graphics("img_9.png")
```

---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="50%", fig.align='center'}
knitr::include_graphics("img_10.png")
```

---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="90%", fig.align='center'}
knitr::include_graphics("img_11.png")
```
---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="100%", fig.align='center'}
knitr::include_graphics("img_12.png")
```
---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="70%", fig.align='center'}
knitr::include_graphics("img_13.png")
```
---
class: inverse, center, middle

# EigenFaces
Aplicando Rotaciones de Jacobi

---

# Descripci贸n del Algoritmo

El **m茅todo de rotaciones Jacobi one sided, es un m茅todo num茅rico para calcular SVD**. El m茅todo utiliza las rotaciones de Jacobi, una transformaci贸n de rotaci贸n, para construir a la matriz ortogonal V y llegar a W.

En este apartado, hacemos uso de este m茅todo, que construimos en una pr谩ctica anterior, como una forma de llegar a la descomposici贸n SVD e implementar el algoritmo Eigenfaces.


---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="50%", fig.align='center'}
knitr::include_graphics("img_14.png")
```

---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="50%", fig.align='center'}
knitr::include_graphics("img_15.png")
```

---

# Implementaci贸n del Algoritmo

```{r, echo = F, eval=T, out.width="100%", fig.align='center'}
knitr::include_graphics("img_16.png")
```

---
class: inverse, center, middle

# Conclusiones
Aplicaciones y enfoques alternativos

---

# Conclusiones y Aplicaciones

Uno de los principales desaf铆os en el reconocimiento de rostros viene dado por las **variaciones dadas en posici贸n (perspectiva), gestualidad e iluminaci贸n de las caras**.


Dos enfoques alternativos:

- Fisher Faces
- Tensor SVD


---

layout: false
class: inverse, center, middle

# Dudas



